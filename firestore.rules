rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Existing rules for 'users' collection (assuming they are secure)
    // Example:
    // match /users/{userId} {
    //   allow read: if request.auth != null;
    //   allow write: if request.auth.uid == userId;
    //   // Add more granular rules for specific fields if needed
    // }

    // Rules for 'friend_requests' collection
    match /friend_requests/{requestId} {
      // Helper function to check if a string is a valid UID (basic check)
      function isValidUid(uid) {
        return uid is string && uid.size() > 0;
      }

      // Helper function to check if the incoming data for create/update is valid
      function isValidRequestData(data) {
        return isValidUid(data.from) &&
               isValidUid(data.to) &&
               data.from != data.to &&
               data.status is string &&
               (data.status == 'FriendshipStatus.pending' ||
                data.status == 'FriendshipStatus.accepted' ||
                data.status == 'FriendshipStatus.rejected') &&
               data.timestamp is timestamp &&
               (data.updatedAt is timestamp || data.updatedAt == null);
      }

      function isPendingStatus(data) {
        return data.status is string && data.status == 'FriendshipStatus.pending';
      }

      // CREATE: User can create a request if 'from' is their UID and status is 'pending'
      allow create: if request.auth != null &&
                       request.resource.data.from == request.auth.uid &&
                       isPendingStatus(request.resource.data) &&
                       isValidRequestData(request.resource.data) &&
                       request.resource.data.timestamp == request.time && // Enforce server timestamp for creation
                       request.resource.data.updatedAt == request.time;   // Enforce server timestamp for initial updatedAt

      // READ: User can read if they are the sender ('from') or receiver ('to')
      allow read: if request.auth != null &&
                     (resource.data.from == request.auth.uid || resource.data.to == request.auth.uid);

      // UPDATE:
      // Receiver can accept/reject a PENDING request. They can only change 'status' and 'updatedAt'.
      allow update: if request.auth != null &&
                       resource.data.to == request.auth.uid && // Only receiver can update
                       isPendingStatus(resource.data) && // Can only update if currently pending
                       request.resource.data.status != resource.data.status && // Status must change
                       (request.resource.data.status == 'FriendshipStatus.accepted' || request.resource.data.status == 'FriendshipStatus.rejected') &&
                       request.resource.data.updatedAt == request.time && // Enforce server timestamp for update
                       // Verify no other fields are changed except status and updatedAt
                       request.resource.data.keys().hasOnly(['from', 'to', 'status', 'timestamp', 'updatedAt']) &&
                       request.resource.data.from == resource.data.from &&
                       request.resource.data.to == resource.data.to &&
                       request.resource.data.timestamp == resource.data.timestamp;


      // DELETE: Sender can delete their PENDING request (cancel)
      allow delete: if request.auth != null &&
                       resource.data.from == request.auth.uid &&
                       isPendingStatus(resource.data);
                       // No need to check request.resource.data for delete
    }
  }
}
